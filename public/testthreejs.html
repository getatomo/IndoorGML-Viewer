<html lang="en">
	<head>
		<title>three.js webgl - buffergeometry</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #cccccc;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				background-color: #050505;
				margin: 0px;
				overflow: hidden;
			}
            .bond {
                width: 5px;
                height: 10px;
                background: #eee;
                display: block;
            }
		</style>
	</head>
	<body>
		<input type="file" id="fileinput" onchange='readText(this)' >
        <input type="checkbox" onclick="select('IS1');" id="cs">Cell
        <input type="checkbox" onclick="select('IS1');" id="nw">Network
		<div id="container"></div>
		<script src='/socket.io/socket.io.js' type='text/javascript'></script>
		<script src='http://code.jquery.com/jquery-1.8.0.min.js' type='text/javascript'></script>
		<script src='/javascripts/chat.js' type='text/javascript'></script>
		<script type="text/javascript" src="/javascripts/earcut.js"></script>
		<script src="/build/three.js"></script>
		<script src="/js/controls/TrackballControls.js"></script>
        <script src="/js/renderers/CSS3DRenderer.js"></script>
		<script src="/js/libs/stats.min.js"></script>

		<script>
			//if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
			var container;//, stats;
			var camera, scene, renderer,controls;
			//var mesh;
			init();
			var tmpVec1 = new THREE.Vector3();
            var tmpVec2 = new THREE.Vector3();
            var tmpVec3 = new THREE.Vector3();
            var tmpVec4 = new THREE.Vector3();
			function init() {
				container = document.getElementById( 'container' );
				var mouse = new THREE.Vector2();
				//
				camera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 1, 3500 );
				camera.position.z = 10;

				controls = new THREE.TrackballControls( camera );
				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;

				scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0x050505, 2000, 3500 );
				//
				scene.add( new THREE.AmbientLight(0x404040  ) );
				var light1 = new THREE.DirectionalLight( 0xffffff, 0.5 );
				light1.position.set( 1, 1, 1 );
				scene.add( light1 );
				var light2 = new THREE.DirectionalLight( 0xffffff, 1.5 );
				light2.position.set( 0, -1, 0 );
				scene.add( light2 );
				//
				
				//
				renderer = new THREE.WebGLRenderer( { antialias: false } );
				renderer.setClearColor( scene.fog.color );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.gammaInput = true;
				renderer.gammaOutput = true;
				container.appendChild( renderer.domElement );
				//
				//stats = new Stats();
				//container.appendChild( stats.dom );
				//

				window.addEventListener( 'resize', onWindowResize, false );
			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			//
			function animate() {
				requestAnimationFrame( animate );
				render();
				//stats.update();
			}
			function render() {
				//var time = Date.now() * 0.001;
				//mesh.rotation.x = time * 0.25;
				//mesh.rotation.y = time * 0.5;
				controls.update();
				renderer.render( scene, camera );
			}
			function onMouseMove( e ) {
				mouse.x = e.clientX;
				mouse.y = e.clientY;
			}
			 function  moveToCenter(myvertices){
        		if(floorflag!=1){
            		floorx=Math.floor(myvertices[0]);
            		floory=Math.floor(myvertices[1]);
            		floorz=Math.floor(myvertices[2]);
            		floorflag=1;
        		}
         		for (var i=0; i<myvertices.length/3; i++) {
            		myvertices[i*3] -= floorx;
            		myvertices[i*3+1] -= floory;
            		myvertices[i*3+2] -= floorz;
        		}
        
        		for (var i=0; i<myvertices.length/3; i++) {
            		myvertices[i*3] =Math.floor( myvertices[i*3]*1000000000)/1000000000
            		myvertices[i*3+1] =Math.floor( myvertices[i*3+1]*1000000000)/1000000000
            		myvertices[i*3+2] =Math.floor( myvertices[i*3+2]*1000000000)/1000000000
        		}
   			}
    		function calVector(myvertices){
        		var vecx=[myvertices[3]-myvertices[0],myvertices[6]-myvertices[0]];
        		var vecy=[myvertices[4]-myvertices[1],myvertices[7]-myvertices[1]];
        		var vecz=[myvertices[5]-myvertices[2],myvertices[8]-myvertices[2]];
        		nx=Math.abs(vecy[0]*vecz[1]-vecz[0]*vecy[1]);
        		ny=Math.abs(-(vecx[0]*vecz[1]-vecz[0]*vecx[1]));
        		nz=Math.abs(vecx[0]*vecy[1]-vecy[0]*vecx[1]);
    		}
 

    var nx;
    var ny;
    var nz;
    var floorx;
    var floory;
    var floorz;
    var floorflag=0;
    var celldictionary={};
    var networkdictionary={};
    var allgeometry={};
    var indoor;
            function select(key){
                for(var k in allgeometry){
                    for(var i=0;i<allgeometry[k].length;i++){
                        console.log(allgeometry[key][i]);
                        allgeometry[k][i].visible=false;
                    }
                }
                for(var i=0;i<allgeometry[key].length;i++){
                    //console.log(allgeometry[key][i]);
                    allgeometry[key][i].visible=true;
                }
            }

        
			function createMesh(){
// create a simple square shape. We duplicate the top left and bottom right
// vertices because each vertex needs to appear once per triangle.
				for (var key in celldictionary) {
            		var surfaces=celldictionary[key];
                    var cell=[];
            		for(var j=0;j<surfaces.length;j++){
            			var geometry = new THREE.BufferGeometry();
            			var surface=surfaces[j];
						var vertices = new Float32Array( surface );

						geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
						var material = new THREE.MeshStandardMaterial( { color: 0xffff00, opacity:0.3, transparent : true, side: THREE.DoubleSide} );
						var mesh = new THREE.Mesh( geometry, material );
						scene.add( mesh );
				        cell.push(mesh);
						
            		}
                    allgeometry[key]=cell;
        		}
        		var cells=indoor.primalSpaceFeature;
        		for(var i=0;i<cells.length;i++){
        			var surfaces=cells[i].geometry;
        			for(var j=0;j<surfaces.length;j++){
        				var polygon=surfaces[j].exterior;
        				var material = new THREE.LineBasicMaterial({color: 0x0000ff});

						var geometry = new THREE.Geometry();
						for(var k=0;k<polygon.length;k+=3){
							geometry.vertices.push(new THREE.Vector3( polygon[k], polygon[k+1], polygon[k+2]));
						}

						var line = new THREE.Line( geometry, material );
						scene.add( line );
                        allgeometry[cells[i].cellid].push(line);
						polygon=surfaces[j].interior;
						if(polygon.length != 0){
							geometry = new THREE.Geometry();
							for(var k=0;k<polygon.length;k+=3){
								geometry.vertices.push(new THREE.Vector3( polygon[k], polygon[k+1], polygon[k+2]));
							}
							var line = new THREE.Line( geometry, material );
							//console.log(polygon);
							scene.add( line );
                            allgeometry[cells[i].cellid].push(line);
						}

        			}
        		}
        		var geometry = new THREE.SphereBufferGeometry( 0.1, 32, 16 );
        		var boxGeometry = new THREE.BoxGeometry( 0.5, 0.5, 1 );
        		var material = new THREE.MeshBasicMaterial( { color: 0xffffff } );
        		for(var key in networkdictionary){
        			var nodes=networkdictionary[key][0];
                    var g=[];
        			for(var i=0;i<nodes.length;i++){
        				var mesh = new THREE.Mesh( geometry, material );
        				mesh.position.x=nodes[i][0];
        				mesh.position.y=nodes[i][1];
        				mesh.position.z=nodes[i][2];
        				scene.add( mesh );
                        g.push(mesh);
        			}
        			var edges=networkdictionary[key][1];
                    var material = new THREE.LineBasicMaterial({color: 0x00ffff,linewidth:10});

        			for(var i=0;i<edges.length;i++){
                        geometry = new THREE.Geometry();
                            for(var k=0;k<edges[i].length;k+=3){
                                geometry.vertices.push(new THREE.Vector3( edges[i][k], edges[i][k+1], edges[i][k+2]));
                            }
                            var line = new THREE.Line( geometry, material );
                            //console.log(polygon);
                            scene.add( line );
                            g.push(line);
        			}
                    allgeometry[key]=g;
        		}

				
			}
	function triangulate(myvertices,interior){

        moveToCenter(myvertices);
        moveToCenter(interior);
        var partition=[];
        var newmyvertices=[];
        var newinterior=[];
            calVector(myvertices);
            
            var max=Math.max(nx,ny,nz);
                if(nz==max){

                    for( var i=0;i<myvertices.length/3;i++){
     
                        newmyvertices.push(myvertices[i*3]);
                        newmyvertices.push(myvertices[i*3+1]);
                       
                    }  
                    for( var i=0;i<interior.length/3;i++){
     
                        newinterior.push(interior[i*3]);
                        newinterior.push(interior[i*3+1]);
                       
                    }  

                }
                else if(nx==max){
                     for(var i=0;i<myvertices.length/3;i++){
     
                        newmyvertices.push(myvertices[i*3+1]);
                        newmyvertices.push(myvertices[i*3+2]);

                    }   
                    for( var i=0;i<interior.length/3;i++){
     
                        newinterior.push(interior[i*3+1]);
                        newinterior.push(interior[i*3+2]);
                       
                    }  
                    
                }
                else{
                     for(var i=0;i<myvertices.length/3;i++){
     
                        newmyvertices.push(myvertices[i*3]);
                        newmyvertices.push(myvertices[i*3+2]);

                    }  
                    for( var i=0;i<interior.length/3;i++){
     
                        newinterior.push(interior[i*3]);
                        newinterior.push(interior[i*3+2]);
                       
                    }  
                }
                var interiorStartIndex=newmyvertices.length/2 - 1;
                var polygonwithhole=newmyvertices.concat(newinterior);
                //var triangle = earcut(newmyvertices);
                var triangle = earcut(polygonwithhole,[interiorStartIndex]);

                    for(var i=0;i<triangle.length;i++){
     
                        partition.push(myvertices[triangle[i]*3]);
                        partition.push(myvertices[triangle[i]*3+1]);
                        partition.push(myvertices[triangle[i]*3+2]);

                    } 

        return partition;
        
    }
    function makeWebglGeometry(){
        var cells=indoor.primalSpaceFeature;
        //console.log(indoor);
        for(var i=0;i<cells.length;i++){
            var cell=[];
            var surfaces=cells[i].geometry;
            for(var j=0;j<surfaces.length;j++){
                var surface=triangulate(surfaces[j].exterior,surfaces[j].interior);

                //console.log("after return"+surface);
                //surfaces[j].exterior=surface;
                cell.push(surface);
            }
    
            celldictionary[cells[i].cellid]=cell;
            
        }


        var graphs=indoor.multiLayeredGraph;

        for(var i=0;i<graphs.length;i++){
            var graph=[];
            var nodes=[];
            var states=graphs[i].stateMember;
            for(var j=0;j<states.length;j++){
                moveToCenter(states[j].position);
                var state=states[j].position;
                nodes.push(state);
            }
            graph.push(nodes);

            var edges=[];
            var trasitions=graphs[i].transitionMember;
            for(var j=0;j<trasitions.length;j++){
                moveToCenter(trasitions[j].line);
                var trasition=trasitions[j].line;
                edges.push(trasition);
            }
            graph.push(edges);

            networkdictionary[graphs[i].graphid]=graph;
            
        }
        createMesh();
    }
		</script>
	<script src='/javascripts/chat_ui.js' type='text/javascript'></script>
	</body>
</html>